//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"
namespace gf
{
/********************   Lambda    ********************/
Lambda::Lambda(Ident p1, Tree *p2)
{
  ident_ = p1;
  tree_ = p2;

}

Lambda::Lambda(const Lambda & other)
{
  ident_ = other.ident_;
  tree_ = other.tree_->clone();

}

Lambda &Lambda::operator=(const Lambda & other)
{
  Lambda tmp(other);
  swap(tmp);
  return *this;
}

void Lambda::swap(Lambda & other)
{
  std::swap(ident_, other.ident_);
  std::swap(tree_, other.tree_);

}

Lambda::~Lambda()
{
  delete(tree_);

}

void Lambda::accept(Visitor *v)
{
  v->visitLambda(this);
}

Lambda *Lambda::clone() const
{
  return new Lambda(*this);
}



/********************   Variable    ********************/
Variable::Variable(Integer p1)
{
  integer_ = p1;

}

Variable::Variable(const Variable & other)
{
  integer_ = other.integer_;

}

Variable &Variable::operator=(const Variable & other)
{
  Variable tmp(other);
  swap(tmp);
  return *this;
}

void Variable::swap(Variable & other)
{
  std::swap(integer_, other.integer_);

}

Variable::~Variable()
{

}

void Variable::accept(Visitor *v)
{
  v->visitVariable(this);
}

Variable *Variable::clone() const
{
  return new Variable(*this);
}



/********************   Application    ********************/
Application::Application(Tree *p1, Tree *p2)
{
  tree_1 = p1;
  tree_2 = p2;

}

Application::Application(const Application & other)
{
  tree_1 = other.tree_1->clone();
  tree_2 = other.tree_2->clone();

}

Application &Application::operator=(const Application & other)
{
  Application tmp(other);
  swap(tmp);
  return *this;
}

void Application::swap(Application & other)
{
  std::swap(tree_1, other.tree_1);
  std::swap(tree_2, other.tree_2);

}

Application::~Application()
{
  delete(tree_1);
  delete(tree_2);

}

void Application::accept(Visitor *v)
{
  v->visitApplication(this);
}

Application *Application::clone() const
{
  return new Application(*this);
}



/********************   Literal    ********************/
Literal::Literal(Lit *p1)
{
  lit_ = p1;

}

Literal::Literal(const Literal & other)
{
  lit_ = other.lit_->clone();

}

Literal &Literal::operator=(const Literal & other)
{
  Literal tmp(other);
  swap(tmp);
  return *this;
}

void Literal::swap(Literal & other)
{
  std::swap(lit_, other.lit_);

}

Literal::~Literal()
{
  delete(lit_);

}

void Literal::accept(Visitor *v)
{
  v->visitLiteral(this);
}

Literal *Literal::clone() const
{
  return new Literal(*this);
}



/********************   MetaVariable    ********************/
MetaVariable::MetaVariable(Integer p1)
{
  integer_ = p1;

}

MetaVariable::MetaVariable(const MetaVariable & other)
{
  integer_ = other.integer_;

}

MetaVariable &MetaVariable::operator=(const MetaVariable & other)
{
  MetaVariable tmp(other);
  swap(tmp);
  return *this;
}

void MetaVariable::swap(MetaVariable & other)
{
  std::swap(integer_, other.integer_);

}

MetaVariable::~MetaVariable()
{

}

void MetaVariable::accept(Visitor *v)
{
  v->visitMetaVariable(this);
}

MetaVariable *MetaVariable::clone() const
{
  return new MetaVariable(*this);
}



/********************   Function    ********************/
Function::Function(Ident p1)
{
  ident_ = p1;

}

Function::Function(const Function & other)
{
  ident_ = other.ident_;

}

Function &Function::operator=(const Function & other)
{
  Function tmp(other);
  swap(tmp);
  return *this;
}

void Function::swap(Function & other)
{
  std::swap(ident_, other.ident_);

}

Function::~Function()
{

}

void Function::accept(Visitor *v)
{
  v->visitFunction(this);
}

Function *Function::clone() const
{
  return new Function(*this);
}



/********************   IntLiteral    ********************/
IntLiteral::IntLiteral(Integer p1)
{
  integer_ = p1;

}

IntLiteral::IntLiteral(const IntLiteral & other)
{
  integer_ = other.integer_;

}

IntLiteral &IntLiteral::operator=(const IntLiteral & other)
{
  IntLiteral tmp(other);
  swap(tmp);
  return *this;
}

void IntLiteral::swap(IntLiteral & other)
{
  std::swap(integer_, other.integer_);

}

IntLiteral::~IntLiteral()
{

}

void IntLiteral::accept(Visitor *v)
{
  v->visitIntLiteral(this);
}

IntLiteral *IntLiteral::clone() const
{
  return new IntLiteral(*this);
}



/********************   FloatLiteral    ********************/
FloatLiteral::FloatLiteral(Double p1)
{
  double_ = p1;

}

FloatLiteral::FloatLiteral(const FloatLiteral & other)
{
  double_ = other.double_;

}

FloatLiteral &FloatLiteral::operator=(const FloatLiteral & other)
{
  FloatLiteral tmp(other);
  swap(tmp);
  return *this;
}

void FloatLiteral::swap(FloatLiteral & other)
{
  std::swap(double_, other.double_);

}

FloatLiteral::~FloatLiteral()
{

}

void FloatLiteral::accept(Visitor *v)
{
  v->visitFloatLiteral(this);
}

FloatLiteral *FloatLiteral::clone() const
{
  return new FloatLiteral(*this);
}



/********************   StringLiteral    ********************/
StringLiteral::StringLiteral(String p1)
{
  string_ = p1;

}

StringLiteral::StringLiteral(const StringLiteral & other)
{
  string_ = other.string_;

}

StringLiteral &StringLiteral::operator=(const StringLiteral & other)
{
  StringLiteral tmp(other);
  swap(tmp);
  return *this;
}

void StringLiteral::swap(StringLiteral & other)
{
  std::swap(string_, other.string_);

}

StringLiteral::~StringLiteral()
{

}

void StringLiteral::accept(Visitor *v)
{
  v->visitStringLiteral(this);
}

StringLiteral *StringLiteral::clone() const
{
  return new StringLiteral(*this);
}





}
