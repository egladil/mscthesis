#ifndef GF_ABSYN_HEADER
#define GF_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.
namespace gf
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Tree;
class Lit;
class Lambda;
class Variable;
class Application;
class Literal;
class MetaVariable;
class Function;
class IntLiteral;
class FloatLiteral;
class StringLiteral;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitTree(Tree *p) = 0;
  virtual void visitLit(Lit *p) = 0;
  virtual void visitLambda(Lambda *p) = 0;
  virtual void visitVariable(Variable *p) = 0;
  virtual void visitApplication(Application *p) = 0;
  virtual void visitLiteral(Literal *p) = 0;
  virtual void visitMetaVariable(MetaVariable *p) = 0;
  virtual void visitFunction(Function *p) = 0;
  virtual void visitIntLiteral(IntLiteral *p) = 0;
  virtual void visitFloatLiteral(FloatLiteral *p) = 0;
  virtual void visitStringLiteral(StringLiteral *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Tree : public Visitable
{
public:
  virtual Tree *clone() const = 0;

};

class Lit : public Visitable
{
public:
  virtual Lit *clone() const = 0;

};



class Lambda : public Tree
{
public:
  Ident ident_;
  Tree *tree_;

  Lambda(const Lambda &);
  Lambda &operator=(const Lambda &);
  Lambda(Ident p1, Tree *p2);
  ~Lambda();
  virtual void accept(Visitor *v);
  virtual Lambda *clone() const;
  void swap(Lambda &);
};

class Variable : public Tree
{
public:
  Integer integer_;

  Variable(const Variable &);
  Variable &operator=(const Variable &);
  Variable(Integer p1);
  ~Variable();
  virtual void accept(Visitor *v);
  virtual Variable *clone() const;
  void swap(Variable &);
};

class Application : public Tree
{
public:
  Tree *tree_1;
  Tree *tree_2;

  Application(const Application &);
  Application &operator=(const Application &);
  Application(Tree *p1, Tree *p2);
  ~Application();
  virtual void accept(Visitor *v);
  virtual Application *clone() const;
  void swap(Application &);
};

class Literal : public Tree
{
public:
  Lit *lit_;

  Literal(const Literal &);
  Literal &operator=(const Literal &);
  Literal(Lit *p1);
  ~Literal();
  virtual void accept(Visitor *v);
  virtual Literal *clone() const;
  void swap(Literal &);
};

class MetaVariable : public Tree
{
public:
  Integer integer_;

  MetaVariable(const MetaVariable &);
  MetaVariable &operator=(const MetaVariable &);
  MetaVariable(Integer p1);
  ~MetaVariable();
  virtual void accept(Visitor *v);
  virtual MetaVariable *clone() const;
  void swap(MetaVariable &);
};

class Function : public Tree
{
public:
  Ident ident_;

  Function(const Function &);
  Function &operator=(const Function &);
  Function(Ident p1);
  ~Function();
  virtual void accept(Visitor *v);
  virtual Function *clone() const;
  void swap(Function &);
};

class IntLiteral : public Lit
{
public:
  Integer integer_;

  IntLiteral(const IntLiteral &);
  IntLiteral &operator=(const IntLiteral &);
  IntLiteral(Integer p1);
  ~IntLiteral();
  virtual void accept(Visitor *v);
  virtual IntLiteral *clone() const;
  void swap(IntLiteral &);
};

class FloatLiteral : public Lit
{
public:
  Double double_;

  FloatLiteral(const FloatLiteral &);
  FloatLiteral &operator=(const FloatLiteral &);
  FloatLiteral(Double p1);
  ~FloatLiteral();
  virtual void accept(Visitor *v);
  virtual FloatLiteral *clone() const;
  void swap(FloatLiteral &);
};

class StringLiteral : public Lit
{
public:
  String string_;

  StringLiteral(const StringLiteral &);
  StringLiteral &operator=(const StringLiteral &);
  StringLiteral(String p1);
  ~StringLiteral();
  virtual void accept(Visitor *v);
  virtual StringLiteral *clone() const;
  void swap(StringLiteral &);
};




}
#endif
